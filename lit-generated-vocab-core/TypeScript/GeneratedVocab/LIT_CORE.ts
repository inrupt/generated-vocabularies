/*
 * Proprietary and Confidential
 *
 * Copyright 2020 Inrupt Inc. - all rights reserved.
 *
 * Do not use without explicit permission from Inrupt Inc.
 */

import { LitVocabTerm, getLocalStore } from "@inrupt/lit-vocab-term";
import dataFactory from "@rdfjs/data-model";
const namedNode = dataFactory.namedNode;

/**
  Generated by artifact generator [@inrupt/lit-artifact-generator], version [0.10.5]
  as part of artifact: [vocab-core], version: [0.3.3]
  at 'Tuesday, May 5, 2020 4:18 PM'.

  Vocabulary built from vocab list file: [lit-rdf-vocab/Core/Vocab-List-LIT-Core.yml].

  The LIT Core Ontology. The LIT is intended to be a collection of utility libraries to ease the
 adoption of RDF for developers.
 */

function _NS(localName: string) { 
  return (namedNode("https://w3id.org/lit/vocab/core#" + localName));
}

const LIT_CORE = {
  PREFIX: "lit_core",
  NAMESPACE: "https://w3id.org/lit/vocab/core#",
  PREFIX_AND_NAMESPACE: { "lit_core": "https://w3id.org/lit/vocab/core#" },
  NS: _NS,

  // *****************
  // All the Classes.
  // *****************

  /**
   * Class of LIT-specific ontologies. Useful for enforcing LIT constraints when generating source
code from LIT ontologies, such as enforcing all terms to have rdfs:label and rdfs:comment predicates.
   */
  Ontology: new LitVocabTerm(
    _NS("Ontology"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`LIT Ontology`, "en")
    .addLabel(`Ontologie LIT`, "fr")
    .addLabel(`Ontología LIT`, "es")
    .addLabel(`LIT-Ontologie`, "de")
    .addComment(`Class of LIT-specific ontologies. Useful for enforcing LIT constraints when generating source
code from LIT ontologies, such as enforcing all terms to have rdfs:label and rdfs:comment predicates.`, "en"),

  /**
   * The class of multi-lingual literal strings. Could be used by code generation to auto-generate
 multi-lingual message resource bundles (e.g. for supporting error messages in multiple languages, or UI labels).
   */
  MultiLingualLiteral: new LitVocabTerm(
    _NS("MultiLingualLiteral"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Multi-lingual literal`, "en")
    .addLabel(`Literal multilingüe`, "es")
    .addComment(`The class of multi-lingual literal strings. Could be used by code generation to auto-generate
 multi-lingual message resource bundles (e.g. for supporting error messages in multiple languages, or UI labels).`, "en"),

  /**
   * This class is used to identify Node Express RDF handlers (i.e. the outer-most handlers of a Node
 server). This can be very useful when determining the overall status of a request, where that single request may have
 initiated, within the server, a very complex workflow that resulted in multiple request/response actions, each of which
 would have their own response codes and data.
   */
  ExpressRdfHandler: new LitVocabTerm(
    _NS("ExpressRdfHandler"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Express RDF Handler`, "en")
    .addLabel(`Express RDF Handler`, "es")
    .addLabel(`Gestionnaire RDF Express`, "fr")
    .addComment(`This class is used to identify Node Express RDF handlers (i.e. the outer-most handlers of a Node
 server). This can be very useful when determining the overall status of a request, where that single request may have
 initiated, within the server, a very complex workflow that resulted in multiple request/response actions, each of which
 would have their own response codes and data.`, "en")
    .addComment(`Esta clase se usa para identificar los manejadores RDF de Node Express (es decir, los manejadores más externos de un nodo)
  servidor). Esto puede ser muy útil al determinar el estado general de una solicitud, donde esa única solicitud puede tener
  inició, dentro del servidor, un flujo de trabajo muy complejo que resultó en múltiples acciones de solicitud / respuesta, cada una de las cuales
  Tendrían sus propios códigos de respuesta y datos.`, "es")
    .addComment(`Cette classe est utilisée pour identifier les gestionnaires RDF Node Express (c’est-à-dire les gestionnaires les plus externes d’un nœud).
   serveur). Cela peut être très utile pour déterminer l’état général d’une demande, où cette demande unique peut avoir
   a initié, au sein du serveur, un flux de travail très complexe qui a entraîné plusieurs actions de demande / réponse, chacune
   aurait ses propres codes et données de réponse.`, "fr"),

  /**
   * This class is used to identify Node Express RDF input handlers (i.e. the outer-most handlers of a
 Node server). This can be very useful when determining the 'entrypoint' into a complex input (i.e. input that contains
 not just the data from the client, but also cookie session information, or proxy information, or infrastructure
 information.
   */
  ExpressRdfHandlerInput: new LitVocabTerm(
    _NS("ExpressRdfHandlerInput"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Express RDF Input Handler`, "en")
    .addComment(`This class is used to identify Node Express RDF input handlers (i.e. the outer-most handlers of a
 Node server). This can be very useful when determining the 'entrypoint' into a complex input (i.e. input that contains
 not just the data from the client, but also cookie session information, or proxy information, or infrastructure
 information.`, "en"),

  /**
   * Class to represent request data.
   */
  RequestData: new LitVocabTerm(
    _NS("RequestData"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Request Data`, "en")
    .addComment(`Class to represent request data.`, "en"),

  /**
   * Class to represent a list of successful outcomes (e.g. when importing a file of people to
 auto-register, this class can be used to represent the list of people successfully registered from that import
 file).
   */
  ResultListSuccess: new LitVocabTerm(
    _NS("ResultListSuccess"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Result List Success`, "en")
    .addComment(`Class to represent a list of successful outcomes (e.g. when importing a file of people to
 auto-register, this class can be used to represent the list of people successfully registered from that import
 file).`, "en"),

  /**
   * Class to represent a list of failed outcomes (e.g. when importing a file of people to
 auto-register, this class can be used to represent the list of people that failed to register from that import
 file).
   */
  ResultListFail: new LitVocabTerm(
    _NS("ResultListFail"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Result List Success`, "en")
    .addComment(`Class to represent a list of failed outcomes (e.g. when importing a file of people to
 auto-register, this class can be used to represent the list of people that failed to register from that import
 file).`, "en"),

  /**
   * Class to represent session info - typically cookies (i.e. if set as a property on a ResponseData
 object returned from a server-side operation, then our Express handler will attempt to set cookies for each property
 contained within the referenced entity.
   */
  SessionInfo: new LitVocabTerm(
    _NS("SessionInfo"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Session Info`, "en")
    .addComment(`Class to represent session info - typically cookies (i.e. if set as a property on a ResponseData
 object returned from a server-side operation, then our Express handler will attempt to set cookies for each property
 contained within the referenced entity.`, "en"),

  /**
   * Class to represent session info that we wish to remove - typically cookies (i.e. if set as a
 property on a ResponseData object returned from a server-side operation, then our Express handler will attempt to
 remove cookies for each property contained within the referenced entity).
NOTE: We may only wish to remove 'some' cookies, and not all - for instance if an Admin user is logged into a
 registration app, and uses their app to log in a beneficiary, then logging out that beneficiary would require removing
 just that beneficies cookie data, but not the Admin user's cookie data, since they may continue using the app to login
 the next beneficary. Therefore this class can contain just the session info we wish to remove.
   */
  RemoveSessionInfo: new LitVocabTerm(
    _NS("RemoveSessionInfo"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Session Info`, "en")
    .addComment(`Class to represent session info that we wish to remove - typically cookies (i.e. if set as a
 property on a ResponseData object returned from a server-side operation, then our Express handler will attempt to
 remove cookies for each property contained within the referenced entity).
NOTE: We may only wish to remove 'some' cookies, and not all - for instance if an Admin user is logged into a
 registration app, and uses their app to log in a beneficiary, then logging out that beneficiary would require removing
 just that beneficies cookie data, but not the Admin user's cookie data, since they may continue using the app to login
 the next beneficary. Therefore this class can contain just the session info we wish to remove.`, "en"),

  /**
   * Class to represent HTTP Headers - our Express handler will attempt to collect all HTTP request
 headers and create a dataset (or this 'type') containing them all.
   */
  HttpHeaderInfo: new LitVocabTerm(
    _NS("HttpHeaderInfo"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Http Header Info`, "en")
    .addComment(`Class to represent HTTP Headers - our Express handler will attempt to collect all HTTP request
 headers and create a dataset (or this 'type') containing them all.`, "en"),

  /**
   * An incoming request can contain lots of query parameters.
   */
  RequestDataQueryParams: new LitVocabTerm(
    _NS("RequestDataQueryParams"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Request Query Params`, "en")
    .addComment(`An incoming request can contain lots of query parameters.`, "en"),

  /**
   * An incoming request can contain lots of cookies and this class is used to represent a collection of
 them.
   */
  RequestDataCookies: new LitVocabTerm(
    _NS("RequestDataCookies"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Request Data Cookies`, "en")
    .addComment(`An incoming request can contain lots of cookies and this class is used to represent a collection of
 them.`, "en"),

  /**
   * Class to represent response data.
   */
  ResponseData: new LitVocabTerm(
    _NS("ResponseData"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Response Data`, "en")
    .addCommentNoLanguage(`Class to represent response data.`),

  /**
   * The class of generic web forms.
   */
  WebForm: new LitVocabTerm(
    _NS("WebForm"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Web Form`, "en")
    .addComment(`The class of generic web forms.`, "en"),

  /**
   * The class of Server-side responses (very generic).
   */
  ServerResponse: new LitVocabTerm(
    _NS("ServerResponse"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Server Response`, "en")
    .addComment(`The class of Server-side responses (very generic).`, "en"),

  /**
   * Event marking a registration (e.g. user registration, account registration).
   */
  EventRegister: new LitVocabTerm(
    _NS("EventRegister"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Event Register`, "en")
    .addComment(`Event marking a registration (e.g. user registration, account registration).`, "en"),

  /**
   * Event marking an unregistration (e.g. unregistering a user, or an account).
   */
  EventUnregister: new LitVocabTerm(
    _NS("EventUnregister"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Event Unregister`, "en")
    .addComment(`Event marking an unregistration (e.g. unregistering a user, or an account).`, "en"),

  /**
   * Event marking a login.
   */
  EventLogin: new LitVocabTerm(
    _NS("EventLogin"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Event Login`, "en")
    .addComment(`Event marking a login.`, "en"),

  /**
   * Event marking a logout.
   */
  EventLogout: new LitVocabTerm(
    _NS("EventLogout"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Event Logout`, "en")
    .addComment(`Event marking a logout.`, "en"),

  /**
   * A generic Agent class, that can be used to represent a User, or an Administrator, or a Shop, or an NGO, or a Donor, etc.
   */
  Agent: new LitVocabTerm(
    _NS("Agent"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Agent`, "en")
    .addComment(`A generic Agent class, that can be used to represent a User, or an Administrator, or a Shop, or an NGO, or a Donor, etc.`, "en"),

  /**
   * A generic User class.
   */
  AgentUser: new LitVocabTerm(
    _NS("AgentUser"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`User`, "en")
    .addComment(`A generic User class.`, "en"),

  /**
   * A generic Admin class.
   */
  AgentAdmin: new LitVocabTerm(
    _NS("AgentAdmin"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Admin`, "en")
    .addComment(`A generic Admin class.`, "en"),

  /**
   * Profile container (which is a collection of Profiles, both core and extensions).
   */
  ProfileContainer: new LitVocabTerm(
    _NS("ProfileContainer"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Profile Container`, "en")
    .addComment(`Profile container (which is a collection of Profiles, both core and extensions).`, "en"),

  // *******************
  // All the Properties.
  // *******************

  /**
   * The root subject for metadata.
 The idea for subject roots is that we could build up an entire graph of
 metadata (i.e. as processing progresses along a chain of processors, with each
 processor enriching this metadata with their specific metadata), and this
 term defines the root term of that graph.
   */
  subjectRoot: new LitVocabTerm(
    _NS("subjectRoot"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Subject root`, "en")
    .addComment(`The root subject for metadata.
 The idea for subject roots is that we could build up an entire graph of
 metadata (i.e. as processing progresses along a chain of processors, with each
 processor enriching this metadata with their specific metadata), and this
 term defines the root term of that graph.`, "en"),

  /**
   * An incoming request can contain lots of contextual information (such as cookie info from the client
 but also server-side context like the machine processing a request, or proxies, etc.). This property is used to
 reference all of that request data.
   */
  hasRequestData: new LitVocabTerm(
    _NS("hasRequestData"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Request Data`, "en")
    .addComment(`An incoming request can contain lots of contextual information (such as cookie info from the client
 but also server-side context like the machine processing a request, or proxies, etc.). This property is used to
 reference all of that request data.`, "en"),

  /**
   * Property pointing to list of successful results.
   */
  hasResultListSuccess: new LitVocabTerm(
    _NS("hasResultListSuccess"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Result List Success`, "en")
    .addComment(`Property pointing to list of successful results.`, "en"),

  /**
   * Property pointing to list of failed results.
   */
  hasResultListFail: new LitVocabTerm(
    _NS("hasResultListFail"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Result List Success`, "en")
    .addComment(`Property pointing to list of failed results.`, "en"),

  /**
   * Link to a collection of session informatoin values, intended to be treated as cookie values (i.e.
 if set as a property on a ResponseData object returned from a server-side operation, then our Express handler will
 attempt to set cookies for each property contained within the referenced entity.
   */
  hasSessionInfo: new LitVocabTerm(
    _NS("hasSessionInfo"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Session Info`, "en")
    .addComment(`Link to a collection of session informatoin values, intended to be treated as cookie values (i.e.
 if set as a property on a ResponseData object returned from a server-side operation, then our Express handler will
 attempt to set cookies for each property contained within the referenced entity.`, "en"),

  /**
   * Link to a collection of HTTP headers associated with an incoming HTTP request.
   */
  hasHttpHeaderInfo: new LitVocabTerm(
    _NS("hasHttpHeaderInfo"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Session Info`, "en")
    .addComment(`Link to a collection of HTTP headers associated with an incoming HTTP request.`, "en"),

  /**
   * An incoming request can contain lots of query parameters.
   */
  hasRequestDataQueryParams: new LitVocabTerm(
    _NS("hasRequestDataQueryParams"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Request Query Params`, "en")
    .addComment(`An incoming request can contain lots of query parameters.`, "en"),

  /**
   * An incoming request can contain lots of cookie values.
   */
  hasRequestDataCookies: new LitVocabTerm(
    _NS("hasRequestDataCookies"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Request Data Cookies`, "en")
    .addComment(`An incoming request can contain lots of cookie values.`, "en"),

  /**
   * When a response can contain lots of information, this predicate tells us the specific response
 data. For example, if storing requests in multiple backends (e.g. file system, SPARQL endpoint, in-memory, etc.), the
 response may contain the results of each separate storage attempt - but this predicate points us directly at the
 response we should consider overall (i.e. the 'definitive' response, which is extremely subjective, in that every
 service will need to determine what that means for itself). It simply provides a simple way for any client to
 immediately and consistently find where to start in navigating a potentially complex server response.
   */
  hasResponseData: new LitVocabTerm(
    _NS("hasResponseData"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`has response data`, "en")
    .addComment(`When a response can contain lots of information, this predicate tells us the specific response
 data. For example, if storing requests in multiple backends (e.g. file system, SPARQL endpoint, in-memory, etc.), the
 response may contain the results of each separate storage attempt - but this predicate points us directly at the
 response we should consider overall (i.e. the 'definitive' response, which is extremely subjective, in that every
 service will need to determine what that means for itself). It simply provides a simple way for any client to
 immediately and consistently find where to start in navigating a potentially complex server response.`, "en"),

  /**
   * The WebID specification should define a namespace for this I think, but currently it doesn't (Feb 2018).
   */
  webId: new LitVocabTerm(
    _NS("webId"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Web ID`, "en")
    .addComment(`The WebID specification should define a namespace for this I think, but currently it doesn't (Feb 2018).`, "en"),

  /**
   * Status Code - based on HTTP status codes, but not necessarily restricted by them.
   */
  statusCode: new LitVocabTerm(
    _NS("statusCode"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Status Code`, "en")
    .addComment(`Status Code - based on HTTP status codes, but not necessarily restricted by them.`, "en"),

  /**
   * Resource Location is intended to stipulate a HTTP 'Location:' header value in server responses.
   */
  resourceLocation: new LitVocabTerm(
    _NS("resourceLocation"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Resource Location`, "en")
    .addComment(`Resource Location is intended to stipulate a HTTP 'Location:' header value in server responses.`, "en"),

  /**
   * Contains the error message text of an error or exception
   */
  errorMessage: new LitVocabTerm(
    _NS("errorMessage"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Error Message`, "en")
    .addComment(`Contains the error message text of an error or exception`, "en"),

  /**
   * Contains the error stack trace of an error or exception - typically only seen in DEBUG mode, and
    not in Production environments (as it can reveal too much internal information from a security perspective.
   */
  errorStackTrace: new LitVocabTerm(
    _NS("errorStackTrace"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Error Stack Trace`, "en")
    .addComment(`Contains the error stack trace of an error or exception - typically only seen in DEBUG mode, and
    not in Production environments (as it can reveal too much internal information from a security perspective.`, "en"),

  /**
   * Used to mark something as being a Link, which effectively means this 'thing' is being 'Linked To'
 from another triple, i.e. it's a 'target' of a link from somewhere else.
   */
  Link: new LitVocabTerm(
    _NS("Link"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Link`, "en")
    .addComment(`Used to mark something as being a Link, which effectively means this 'thing' is being 'Linked To'
 from another triple, i.e. it's a 'target' of a link from somewhere else.`, "en"),

  /**
   * Used to specify a Link to a new subject, e.g. for Skolemization when we want to avoid using blank nodes.
   */
  hasLink: new LitVocabTerm(
    _NS("hasLink"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has link`, "en")
    .addComment(`Used to specify a Link to a new subject, e.g. for Skolemization when we want to avoid using blank nodes.`, "en"),

  /**
   * The source of a link to this entity, i.e. from where this entity is Linked.
   */
  isLinkedFrom: new LitVocabTerm(
    _NS("isLinkedFrom"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Is Linked From`, "en")
    .addComment(`The source of a link to this entity, i.e. from where this entity is Linked.`, "en"),

  /**
   * The short form user name.
   */
  username: new LitVocabTerm(
    _NS("username"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`User Name`, "en")
    .addComment(`The short form user name.`, "en"),

  /**
   * Property linking a Profile with it's container.
   */
  hasProfileContainer: new LitVocabTerm(
    _NS("hasProfileContainer"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Profile Container`, "en")
    .addComment(`Property linking a Profile with it's container.`, "en"),

  /**
   * An Authorization Token used to authenticate a user.
   */
  authorizationToken: new LitVocabTerm(
    _NS("authorizationToken"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Authorization Token`, "en")
    .addComment(`An Authorization Token used to authenticate a user.`, "en"),

  /**
   * Property linking a resource to a specific SHACL shape (with the intent that
 any request with this property will be validated against the specified shape).
   */
  hasShaclShape: new LitVocabTerm(
    _NS("hasShaclShape"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has SHACL Shape`, "en")
    .addComment(`Property linking a resource to a specific SHACL shape (with the intent that
 any request with this property will be validated against the specified shape).`, "en"),

  /**
   * Property linking a resource to a specific vocabulary (with the intent that this
 vocabulary will be used in SHACL validation to provide rdfs:subClassOf inference).
   */
  hasVocabulary: new LitVocabTerm(
    _NS("hasVocabulary"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addLabel(`Has Vocabulary`, "en")
    .addComment(`Property linking a resource to a specific vocabulary (with the intent that this
 vocabulary will be used in SHACL validation to provide rdfs:subClassOf inference).`, "en"),

  // *******************
  // All the Literals.
  // *******************

  /**
   * Internal error: A value of 'null' was provided when our system specifically disallows 'null' values here.
   */
  errRequireNotNull: new LitVocabTerm(
    _NS("errRequireNotNull"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Internal error: A value of 'null' was provided when our system specifically disallows 'null' values here.`, "en"),

  /**
   * UUID provided for conversion [{{0}}] was too short at only [{{1}}] characters long (we requirea minimum of [{{2}}]).
   */
  errUuidTooShort: new LitVocabTerm(
    _NS("errUuidTooShort"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`UUID provided for conversion [{{0}}] was too short at only [{{1}}] characters long (we requirea minimum of [{{2}}]).`, "en"),

  /**
   * Cannot create a builder with a focus subject relative to a blank node: [{{0}}] (relative part was [{{1}}]).
   */
  errFocusSubjectRelativeToBlankNode: new LitVocabTerm(
    _NS("errFocusSubjectRelativeToBlankNode"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Cannot create a builder with a focus subject relative to a blank node: [{{0}}] (relative part was [{{1}}]).`, "en")
    .addMessage(`SPANISH text - Cannot create a builder with a focus subject relative to a blank node: [{{0}}] (relative part was [{{1}}]).`, "es")
    .addMessage(`FRENCH - Cannot create a builder with a focus subject relative to a blank node: [{{0}}] (relative part was [{{1}}]).`, "fr"),

  /**
   * Cannot convert dataset to a simple object, as it contains at least two triples with different subjects: [{{0}}] and [{{1}}]
   */
  errDifferentSubjectsPreventsConversionToObject: new LitVocabTerm(
    _NS("errDifferentSubjectsPreventsConversionToObject"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Cannot convert dataset to a simple object, as it contains at least two triples with different subjects: [{{0}}] and [{{1}}]`, "en"),

  /**
   * Must provide both an error to wrap and a message - but one (or both) were missing (error: [{{0}}], message: [{{1}}].
   */
  errWrappingErrorNeedsErrorAndMessage: new LitVocabTerm(
    _NS("errWrappingErrorNeedsErrorAndMessage"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Must provide both an error to wrap and a message - but one (or both) were missing (error: [{{0}}], message: [{{1}}].`, "en")
    .addMessage(`Debe proporcionar tanto un error para envolver como un mensaje, pero faltaba uno (o ambos) (error: [{{0}}], mensaje: [{{1}}].`, "es"),

  /**
   * The mandatory field [{{0}}] was not provided
   */
  errMandatoryFieldNotProvided: new LitVocabTerm(
    _NS("errMandatoryFieldNotProvided"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`The mandatory field [{{0}}] was not provided`, "en")
    .addMessage(`No se proporcionó el campo obligatorio [{{0}}]`, "es"),

  /**
   * The mandatory literal field [{{0}}] has [{{1}}] values when we explicitly require only 1 - needed [{{2}}]
   */
  errMandatoryLiteralExpectedOne: new LitVocabTerm(
    _NS("errMandatoryLiteralExpectedOne"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`The mandatory literal field [{{0}}] has [{{1}}] values when we explicitly require only 1 - needed [{{2}}]`, "en")
    .addMessage(`El campo literal obligatorio [{{0}}] tiene valores [{{1}}] cuando explícitamente requiere solo 1 - necesaria [{{2}}]`, "es"),

  /**
   * The mandatory IRI field [{{0}}] has [{{1}}] values when we explicitly require only 1
   */
  errMandatoryIriExpectedOne: new LitVocabTerm(
    _NS("errMandatoryIriExpectedOne"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`The mandatory IRI field [{{0}}] has [{{1}}] values when we explicitly require only 1`, "en")
    .addMessage(`El campo IRI obligatorio [{{0}}] tiene valores [{{1}}] cuando explícitamente requiere solo 1`, "es"),

  /**
   * Expected a literal value, but found the IRI [{{0}}]
   */
  errLiteralExpectedButFoundIri: new LitVocabTerm(
    _NS("errLiteralExpectedButFoundIri"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Expected a literal value, but found the IRI [{{0}}]`, "en")
    .addMessage(`Esperaba un valor literal, pero encontró el IRI [{{0}}]`, "es"),

  /**
   * Incoming request (for resource [{{0}}]) has unsupported content type:[{{1}}]
   */
  errUnsupportedContentType: new LitVocabTerm(
    _NS("errUnsupportedContentType"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Incoming request (for resource [{{0}}]) has unsupported content type:[{{1}}]`, "en")
    .addMessage(`La solicitud entrante (para el recurso [{{0}}]) tiene un tipo de contenido no admitido: [{{1}}]`, "es"),

  /**
   * We cannot determine a supported RDF format from the extension of the specified filename: [{{0}}]
   */
  errUnsupportedFileExtension: new LitVocabTerm(
    _NS("errUnsupportedFileExtension"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`We cannot determine a supported RDF format from the extension of the specified filename: [{{0}}]`, "en")
    .addMessage(`No podemos determinar un formato RDF compatible a partir de la extensión del nombre de archivo especificado: [{{0}}]`, "es"),

  /**
   * Failed to load stream from IRI [{{0}}]
   */
  errLoadingStreamFromIri: new LitVocabTerm(
    _NS("errLoadingStreamFromIri"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Failed to load stream from IRI [{{0}}]`, "en")
    .addMessage(`Error al cargar la secuencia desde IRI [{{0}}]`, "es"),

  /**
   * Failed to load stream from local resource [{{0}}] (we expect it to exist on the current Classpath, e.g. as a file on the local file system, or within a JAR on the Classpath)
   */
  errLoadingStreamFromJavaResource: new LitVocabTerm(
    _NS("errLoadingStreamFromJavaResource"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Failed to load stream from local resource [{{0}}] (we expect it to exist on the current Classpath, e.g. as a file on the local file system, or within a JAR on the Classpath)`, "en")
    .addMessage(`Error al cargar la secuencia desde el recurso local [{{0}}] (esperamos que exista en el Classpath actual, p. como un archivo en el sistema de archivos local, o dentro de un JAR en el Classpath)`, "es"),

  /**
   * Failed to load stream from [{{0}}] in format [{{1}}] into named graph [{{2}}]
   */
  errLoadingStreamIntoNamedGraph: new LitVocabTerm(
    _NS("errLoadingStreamIntoNamedGraph"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Failed to load stream from [{{0}}] in format [{{1}}] into named graph [{{2}}]`, "en")
    .addMessage(`Error al cargar la transmisión desde [{{0}}] en formato [{{1}}] en el gráfico con nombre [{{2}}]`, "es"),

  /**
   * Incoming request has an empty body (but we require a body). Request content type: [{{0}}]
   */
  errEmptyRequestBody: new LitVocabTerm(
    _NS("errEmptyRequestBody"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Incoming request has an empty body (but we require a body). Request content type: [{{0}}]`, "en")
    .addMessage(`La solicitud entrante tiene un cuerpo vacío (pero requerimos un cuerpo). Solicitar tipo de contenido: [{{0}}]`, "es"),

  /**
   * Internal LIT log message: [{{0}}]
   */
  errGenericInternal: new LitVocabTerm(
    _NS("errGenericInternal"),
    dataFactory,
    getLocalStore(),
    false
  )
    .addMessage(`Internal LIT log message: [{{0}}]`, "en")
    .addMessage(`Mensaje de registro interno de LIT: [{{0}}]`, "es"),
};

export { LIT_CORE };
